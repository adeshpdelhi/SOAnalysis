				 supports generics to specify the type of objects stored in a collection instance.
In 1998,  Generic Java was incorporated in Java with the addition of wildcards.


According to 
The following block of Java code illustrates a problem that exists when not using generics. First, it declares an .
Although the code is compiled without error, it throws a runtime exception () when executing the third line of code. This type of problem can be avoided by using generics and is the primary motivation for using generics.
Using generics, the above code fragment can be rewritten as follows:
The type parameter  by the code generated by the compiler.
Compiling the third line of this fragment with J2SE 5.0 (or later) will yield a 
Here is a small excerpt from the definition of the interfaces :
A type argument for a parameterized type is not limited to a concrete class or interface. Java allows the use of . Given that the exact type represented by a wildcard is unknown, restrictions are placed on the type of methods that may be called on an object which uses parameterized types.
As an example of an unbounded wildcard,  elements to the list is not allowed, since the element type is not known.
To specify the , while adding non-null elements is once again not allowed.
The use of wildcards above adds flexibility since there is not any inheritance relationship between any two parameterized types with concrete type as type argument. Neither :
The solution with wildcards works because it disallows operations that would violate type safety.
To specify the lower bounding class of a type wildcard, the .
The mnemonic PECS (Producer Extends, Consumer Super) from the book  gives an easy way to remember when to use wildcards (corresponding to covariance and contravariance) in Java.
Here is an example of a generic Java class, which can be used to represent individual entries (key to value mappings) in a :
This generic class could be used in the following ways, for example:
It outputs:
Java SE 7 and above allow the programmer to substitute an empty pair of angle brackets ( can be rewritten as:
Here is an example of a generic method using the generic class above:
Note: If we remove the first &lt;Type&gt; in the above method, we will get compilation error (cannot find symbol 'Type') since it represents the declaration of the symbol.
In many cases the user of the method need not indicate the type parameters, as they can be inferred:
The parameters can be explicitly added if needed:
The use of  versions must be used instead:
There is also the possibility to create generic methods based on given parameters.
In such cases you can't use primitive types either, e.g.:
Although exceptions themselves cannot be generic, generic parameters can appear in a throws clause:
Generics are checked at compile-time for type-correctness. The generic type information is then removed in a process called , which ordinarily contains arbitrary objects. The compile-time check guarantees that the resulting code is type-correct.
Because of type erasure, type parameters cannot be determined at run-time. For example, when an ).
Demonstrating this point, the following code outputs "Equal":
Another effect of type erasure is that a generic class cannot extend the Throwable class in any way, directly or indirectly:
The reason why this is not supported is due to type erasure:
Due to type erasure, the runtime will not know which catch block to execute, so this is prohibited by the compiler.
Java generics differ from . Java generics generate only one compiled version of a generic class or function regardless of the number of parameterizing types used. Furthermore, the Java run-time environment does not need to know which parameterized type is used because the type information is validated at compile-time and is not included in the compiled code. Consequently, instantiating a Java class of a parameterized type is impossible because instantiation requires a call to a constructor, which is unavailable if the type is unknown.
For example, the following code cannot be compiled:
Because there is only one copy per generic class at runtime, static variables are shared among all the instances of the class, regardless of their type parameter. Consequently, the type parameter cannot be used in the declaration of static variables or in static methods.

