				 project that provides framework and end-user components related to graphical applications.


GEF was initially developed as part of IBM's etools (com.ibm.etools.gef) and was contributed to  and GEF (MVC), a related model-view-controller framework that can be used to realized graphical editors as part of Eclipse Rich Client Platform (RCP) applications. The first release at Eclipse was GEF 2.1.0 in March 2003. The next major version, GEF 3.0.0, was released in June 2004, providing many new features like support for rules and guides. Zest was added as a third project component in 2007 in version 1.0.0 as part of the GEF 3.4.0 release. Since 2004, when GEF 3.0.0 was released, only compatible changes have been applied to the framework's application programming interface (API).
A new major revision of the framework has been developed in parallel to the maintenance of the GEF 3.x components by the project team since 2010. It is a complete redesign that is much more modular, uses JavaFX instead of SWT as underlying rendering framework, and can be used also independently of Eclipse RCP applications. Commonly referred to as GEF4, its components were initially released in version 0.1.0 (with still provisional API) in June 2015 as part of the GEF 3.10.0 (Mars) release. The GEF4 components are to be published in version 1.0.0 as part of the GEF 4.0.0 (Neon) release in June 2016.
GEF 3.x provides framework technology to realize graphical editors and views as part of  applications. It is internally decomposed into three components:
While graphical applications can be built on top of the GEF 3.x components directly, Draw2d and GEF (MVC) are also used by the  to create the code for both the data model and the graphical editor.
Editors created with GEF (MVC) consist of the following components:
GEF makes heavy use of . These patterns are often mandatory under GEF and developers are required to understand them.
Any user action with the editor can generate a request. The nature of the request is understood by the context of invocation. The context is determined by the EditPart the user interacts with and the active tool. The tool can be any selected entry in a tool palette. The request is handed over to the selected EditPart, which in turn returns a Command.
This is achieved using the  mechanism over Editpolicies. The editpolicies determine if they can handle the request, otherwise they pass on to the next editpolicy. The order of declaration of editpolicies determine the order in which the request is passed around. The capable editpolicy creates a command. This command is handed back to the tool which initiated the "Request". Execution of the command causes the model to be modified (Response).
