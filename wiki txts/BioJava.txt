 for example:
The BioJava project grew out of work by Thomas Down and Matthew Pocock to create an API to simplify development of Java-based Bioinformatics tools. BioJava is an active open source project that has been developed over more than 12 years and by more than 60 developers. BioJava is one of a number of Bio* projects designed to reduce code duplication. etc.
Version 3.0.5 was a major update to the prior versions. It contained several independent modules. The old project has been moved to a separate project called BioJava-legacy project.


BioJava provides software modules for many of the typical tasks of bioinformatics programming. These include:
In the year 2008, BioJava's first Application note was published.
In October 2012, the most recent paper on BioJava was published..
During 2014-2015, large parts of the original code base were rewritten. BioJava 3 is a clear departure from the version 1 series. It now consists of several independent modules built using an automation tool called 
The following sections will describe several of the new modules and highlight some of the new features that are included in the latest version of BioJava.
This module provides Java  sequences. The classes were designed so that the names are familiar and make sense to biologists and also provide a concrete representation of the steps in going from a gene sequence to a protein sequence for computer scientists and programmers.
A major change between the legacy BioJava project and BioJava3 lies in the way framework has been designed to exploit then-new innovations in Java. A sequence is defined as a generic  allowing the rest of the modules to create any utility that operates on all sequences. Specific classes for common sequences such as DNA and proteins have been defined in order to improve usability for biologists. The translation engine really leverages this work by allowing conversions between DNA, RNA and amino acid sequences. This engine can handle details such as choosing the codon table, converting start codons to methionine, trimming stop codons, specifying the reading frame and handing ambiguous sequences.
Special attentions has been paid to designing the storage of sequences to minimize space needs. Special design patterns such as the  allowed the developers to create the framework such that sequences can be stored in memory, fetched on demand from a web service such as UniProt, or read from a FASTA file as needed. The latter two approaches save memory by not loading sequence data until it is referenced in the application. This concept can be extended to handle very large genomic datasets, such as NCBI GenBank or a proprietary database.
The protein structure modules provide tools to represent and manipulate 3D biomolecular structures. They focus on protein structure comparison.
The following algorithms have been implemented and included in BioJava.
These algorithms are used to provide the RCSB Protein Data Bank (PDB)
Parsers for PDB
Below is an outline of the code to initialize a window that will display and compare two protein sequences. Please bear in mind that this is just an outline of the code. To make this work one will need to import the correct found in the "org.biojava.bio.structure" package and add also handle exceptions by using a try-catch block.
The code aligns the two protein sequences "4hhb.A" and "4hhb.B" based on the FATCAT rigid algorithm.
This module is focused on the creation of gene sequence objects from the core module. This is realised by supporting the parsing of the following popular standard file formats generated by open source gene prediction applications:
Then the gene sequence objects are written out as a GFF3 format and is imported into GMOD. These file formats are well defined but what gets written in the file is very flexible.
The following code example takes a 454scaffold file that was used by genemark to predict genes and returns a collection of ChromosomeSequences. Each chromosome sequence maps to a named entry in the fasta file and would contain N gene sequences. The gene sequences can be +/- strand with frame shifts and multiple transcriptions.
Passing the collection of ChromosomeSequences to GeneFeatureHelper.getProteinSequences would return all protein sequences. You can then write the protein sequences to a fasta file.
You can also output the gene sequence to a fasta file where the coding regions will be upper case and the non-coding regions will be lower case
You can easily write out a gff3 view of a ChromosomeSequence with the following code.
For providing input-output support for several common variants of the FASTQ file format from the next generation sequencers,.
Work is in progress towards providing a complete set of java classes to do conversions between different file formats where the list of supported gene prediction applications and genome browsers will get longer based on end user requests.
This module contains several classes and methods that allow users to perform pairwise and multiple sequence alignment.

For optimal global alignment, BioJava implements the  algorithm has been implemented. The outputs of both local and global alignments are available in standard formats.
An  on how to use the libraries is shown below.
An example call to the above function would look something like this:


In addition to these two algorithms, there is an implementation of Guanâ€“Uberbacher algorithm which performs global sequence alignment very efficiently since it only uses linear memory.
For , any of the methods discussed above can be used to progressively perform a multiple sequence alignment.
The ModFinder module provides new methods to identify and classify protein modifications in protein 3D structures. Over 400 different types of protein modifications such as  The module also provides an API for detecting protein modifications within protein structures.



There are plans to include further protein modifications by integrating other resources such as 
This module attempts to provide accurate physio-chemical properties of proteins. The properties that can calculated using this module are as follows:
The precise molecular weights for common isotopically labelled amino acids are included in this module. There also exists flexibility to define new amino acid molecules with their molecular weights using simple  experiments.
The goal of this module is to provide users ways to find disorders in protein molecules. BioJava includes a Java implementation of the  on a modern quad-core machine, as compared to the legacy C implementation.
There are two ways to use this module:
The following examples show how to use the module and make function calls to get information about protein disorders. The first two examples make library function calls to calculate the probability of disorder for every residue in the sequence provided.
The third and fourth examples demonstrates how easily one can get the disordered regions of the protein.




BioJava module 


Predict disorder values for sequences from input file  available on the computer.
Predict disorder values for sequences from input file  file and limit the number of threads to two.
The arguments can be provided in any order.
As per the current trends in bioinformatics, web based tools are gaining popularity. The web service module allows bioinformatics services to be accessed using 
The need for customized software in the field of  all provide tool-kits with multiple functionality that make it easier to create customized pipelines or analysis.
As the names suggest, the projects mentioned above use different programming languages. All of these APIs offer similar tools so on what criteria should one base their choice? For programmers who are experienced in only one of these languages, the choice is straightforward. However, for a well-rounded bioinformaticist who knows all of these languages and wants to choose the best language for a job, the choice can be made based on the following guidelines given by a software review done on the Bio* tool-kits.
In general, for small programs (&lt;500 lines) that will be used by only an individual or small group, it is hard to beat . These constraints probably cover the needs of 90 per cent of personal bioinformatics programming.
For beginners, and for writing larger programs in the Bio domain, especially those to be shared and supported by others,  clarity and brevity make it very attractive.
For those who might be leaning towards a career in bioinformatics and who want to learn only one language,  has the widest general programming support, very good support in the Bio domain with BioJava, and is now the de facto language of business (the new COBOL, for better or worse).
Apart from these Bio* projects there is another project called  between BioJava and STRAP are as follows:


The following projects make use of BioJava.
